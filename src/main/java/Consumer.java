import com.mpatric.mp3agic.*;

import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/*TODO
    1. give and name of song except from artist name
    2. save chunks or merge them or both of them
    3.may auto-generate name and it is not needed to be given by keyboard->maybe static doesn't work if run consumer in different machines
    4.may use info objects and list instead of list of brokers. Then there will be changes in connect,register,findCorrespondingBroker
    5. if i use info objects i must change constructor of Node class because i won't use the initialise of list of brokers
    6. use super.connect and super.disconnect they work but i must setSocket and objectstreams
 */

//name may be given by keyboard OR it can be generated by name of class+id
public class Consumer extends Node{

    private Socket requestSocket;
    private ObjectOutputStream out;
    private ObjectInputStream in;
    private Scanner scn;
    private Info info;
    private String[] connectedBroker;

    public Consumer() {
        super();
        this.scn = new Scanner(System.in);
    }


    public Consumer(String name, String ip,int port) {
        super(name, ip,port);
        this.scn = new Scanner(System.in);
        connect(this.getIp(), this.getPort());
    }

    //TODO TAKE AN NAME OF SONG
    @Override
    public void connect(String ip, int port) {
        //List<Broker> listOfBrokers = new ArrayList<>();
        //IT WORKS IF I USE THIS I DELETE THE NEXT ONES AND ALL SETSOCKET etc methods and also I MUST DELETE finally FROM connect in Node class
        super.connect(ip,port);
        this.in = this.getInputStream();
        this.out = this.getOutputStream();
        this.requestSocket = this.getSocket();
        try {
            //HOUSTON MAY HAVE A PROBLEM OR GET THE LIST OF INFO OBJECTS
            //listOfBrokers = (List<Broker>) in.readObject();
            this.info = (Info) in.readObject();
            setInfo(this.info);
            findCorrespondingBroker();
        } catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            this.disconnect();
        }
    }

    private void findCorrespondingBroker() {
        System.out.println("Give artist name: ");
        //check if input is correct and not /n char
        String artist = scn.nextLine();
        boolean isOK = false;
        String[] cb = null;
        ArtistName artistName = null;
        //Changes if we use Info object
        while (!isOK) {
            while (artist.isEmpty()) {
                System.out.println("Invalid artist name. Try again");
                System.out.println("Give artist name: ");
                artist = scn.nextLine();
            }
            artistName = new ArtistName(artist);
            for (ArtistName a : this.getInfo().getListOfBrokersInfo().keySet()) {
                if (a.getArtistName().equals(artistName.getArtistName())) {
                    isOK = true;
                    break;
                }
                if (isOK) {
                    cb = this.getInfo().getListOfBrokersInfo().get(a);
                    break;
                }
            }
            if (!isOK) {
                System.out.println("Artist name is not founded");
                System.out.println("Please give an other artist name: ");
                artist = scn.nextLine();
            }
        }
        register(cb,artistName);
    }

    //Changes if we use Info object
    //VIEW THE REGISTER MAYBE IT WANT TO CHECK IF STREAM IS OPEN IN ORDER TO SEND MESSAGE REGISTER
    private void register(String[] broker, ArtistName artistName){
        if(broker!=null && artistName!=null){
            if((broker[1].equals(this.getIp())) && (Integer.parseInt(broker[2]) == this.getPort())){
                /*
                for(ArtistName a : broker.getRelatedArtists()){
                    if (a.getArtistName().equals(artistName.getArtistName())){
                        try {
                            this.out.writeObject("Register");
                            break;
                        } catch (IOException e) {
                            e.printStackTrace();
                            break;
                        }

                    }
                }*/
                try {
                    this.out.writeObject("Register");
                    this.out.flush();
                    this.out.writeObject(this.getName());
                    this.out.flush();
                    //this.out.writeObject(artistName);
                    this.setConnectedBroker(broker);
                    transaction(artistName);
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            else{
                //TODO I DON'T KNOW IF DISCONNECT WILL WORK->CHECK IT
                super.disconnect();
                this.setPort(Integer.parseInt(broker[2]));
                this.setIp(broker[1]);
                //if super.disconnect(); doesn't work
                /*
                try {
                    this.requestSocket.close();
                    this.out.close();
                    this.in.close();

                } catch (IOException e) {
                    System.out.println("Failed to disconnect");
                    e.printStackTrace();
                }*/
                try {
                    super.connect(this.getIp(),this.getPort());
                    this.requestSocket=this.getSocket();
                    this.out = this.getOutputStream();
                    this.in = this.getInputStream();
                    System.out.println("Success to connected to "+broker[0]);
                    out.writeObject(this.getClass().getSimpleName());
                    out.flush();
                    this.out.writeObject("Register");
                    this.out.flush();
                    this.out.writeObject(this.getName());
                    this.out.flush();
                    this.setConnectedBroker(broker);
                    //this.setInputStream(this.in);
                    //this.setOutputStream(this.out);
                    //this.setSocket(this.requestSocket);
                    transaction(artistName);
                } catch (Exception e) {
                    System.out.println("Failed to connect to "+broker[0]);
                    e.printStackTrace();
                }
            }
        }
        else {
            System.out.println("Null broker or artist name");
            this.disconnect();
        }

    }

    private void setConnectedBroker(String[] broker) {
        this.connectedBroker=broker;
    }

    private String[] getConnectedBroker(){
        return this.connectedBroker;
    }

    //TODO ean dn uparxei to sugkekrimeno song o publisher gurnaei katallhlo mhnuma ston broker kai autos me thn seira tou ston consumer
    private void transaction(ArtistName artistName) {
        //String line = "";
        //boolean isExit = false;

        System.out.println("Give name of song that you want to listen from artist "+artistName.getArtistName()+" : ");
        String song = scn.nextLine();
        while (song.isEmpty()) {
            System.out.println("Invalid song name for this artist. Try again");
            System.out.println("Give song's name: ");
            song = scn.nextLine();
        }
        try {
            this.out.writeObject(artistName);
            this.out.flush();
            this.out.writeObject(song);
            this.out.flush();
            Value v = (Value) this.in.readObject();
            //TODO save chunks or merge them
            while (v!=null){
                v = (Value) this.in.readObject();
                if(v.getFailure()){
                    System.out.println("Failure -> Possibly there is not song with this name");
                    break;
                }
                //save chunks or merge them
                save(v);
            }
            System.out.println("Press continue if you want to listen an other songs. Else press exit: ");
            String ans1 = scn.nextLine();
            while (!(ans1.equalsIgnoreCase("continue")) && !(ans1.equalsIgnoreCase("exit"))){
                System.out.println("Invalid answer. Try again");
                System.out.println("Press continue if you want to listen an other songs. Else press exit: ");
                ans1 = scn.nextLine();
            }
            if(ans1.equalsIgnoreCase("continue")) {
                this.setPort(-1);
                this.setIp(null);
                findCorrespondingBroker();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //TODO save method -> write chunk with metadata
    private void save(Value v) {
        File currentDirectory = new File(new File(".").getAbsolutePath());
        String currentDirectoryPath = currentDirectory.getAbsolutePath()
                .substring(0,currentDirectory.getAbsolutePath().length() - 1);
        String basePath = currentDirectoryPath+"Saved Songs\\";
        MusicFile m = v.getMusicFile();
        String fileName = m.getArtistName()+"-"+m.getTrackName()+Integer.toString(m.getId())+".mp3";
        String path = basePath + fileName;
        try {
            File of = new File(basePath, fileName);
            OutputStream out = new FileOutputStream(of);
            out.write(m.getMusicFileExtract());
            Mp3File chunk = new Mp3File(path);
            ID3v2 id3v2Tag;
            if (chunk.hasId3v2Tag()) {
                id3v2Tag = chunk.getId3v2Tag();
            } else {
                id3v2Tag = new ID3v24Tag();
                chunk.setId3v2Tag(id3v2Tag);
            }
            id3v2Tag.setTrack(m.getTrackName());
            id3v2Tag.setArtist(m.getArtistName());
            id3v2Tag.setAlbum(m.getAlbumInfo());
            id3v2Tag.setGenreDescription(m.getGenre());
            chunk.save(path);

        } catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            try {
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }


    }

    @Override
    public void disconnect(){
        /*try {
            this.out.writeObject(this.getName()+"says bye bye");
            this.out.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }*/
        super.disconnect();

        try {
            this.scn.close();
        }
        catch (Exception e){
            e.printStackTrace();
        }

    }

    public Info getInfo(){
        return this.info;
    }

    public void setInfo(Info info){
        this.info = info;
    }


    public void playData(ArtistName artistName, Value value){}

    //MAIN
    public static void main(String args[]){
        //may auto-generate name and it is not needed to be given by keyboard
        /*args[0]->name
          args[1]->IP
          args[2]->Port
         */
        new Consumer(args[0],args[1],Integer.parseInt(args[2])).connect(args[1],Integer.parseInt(args[2]));
    }
}